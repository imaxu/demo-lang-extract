# -*- coding:utf-8 -*-

class Generator(object):
    """多语言词典脚本生成器

    提供对已提取词组生成language.js文件。
    """
    def __init__(self,path,mode,lang="zh-cn"):
        """
        Args:
            path:生成文件的保存路径。
            mode:指定生成器模式，A = Create 创建模式  U = Update 更新模式。
        Returns:
            Raises:
                AttributeError:缺少参数或者参数超出范围
        """
        if not path or len(path) == 0:
            raise AttributeError("invalid path") 
        self.path = path

        if not mode or str.lower(mode) not in ["a","u"]:
            raise AttributeError("invalid mode with %s" % mode) 
        self.mode = str.lower(mode)
        if not lang:
            raise AttributeError("invalid lang") 
        self.lang = str.lower(lang)        

    def __create__(self):
        import os,time
        full_path = self.path
        file_path,file_name = os.path.split(full_path)

        if os.access(full_path, os.F_OK):
            raise RuntimeError("file was exists,we can not create.path:%s" % full_path)
        if not os.path.exists(file_path):
            os.makedirs(file_path)

        file = open(full_path,"a+",encoding="UTF-8")
        file.writelines("/** @Auth -- generated by lang_extract.py \n")
        file.writelines("**  @Desc 这个文件是lang_extract.py自动生成，编辑自定义内容会被覆盖。\n")
        file.writelines("**  @LastUpdatetime %s \n" % time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        file.writelines("**/\n")
        file.writelines("var _dict = (function(){\n")
        file.writelines("\treturn {\n")
        file.writelines("\t\t\"lang_name\":\"%s\",\n" % self.lang)
        file.writelines("\t\t/** translate content start **/\n")
        # generate translate contents.
        for l in self.langs:
            file.writelines("\t\t\"%s\":\"\",\n" % l)
        # / generate translate contents.
        file.writelines("\t\t/** translate content end **/\n")
        file.writelines("\t};\n")
        file.writelines("})();\n")
        file.flush()
        file.close()
    
    def __update__(self):
        import shutil,os,time
        export_full_path = self.path

        if not os.path.exists(export_full_path):
            raise RuntimeError("file is not exists,we can not update data.path:%s" % export_full_path)

        langs = self.langs
        swp_file_full_path = "%s.swp" % export_full_path
        bak_file_full_path = "%s.bak" % export_full_path

        shutil.copy2(export_full_path,swp_file_full_path)
        shutil.copy2(export_full_path,bak_file_full_path)

        swp_file = open(swp_file_full_path,"w+",encoding="UTF-8")
        source_file = open(export_full_path,"r",encoding="UTF-8")

        is_trans_area = False
        writed = []
        for index,line in enumerate(source_file):
            if "@LastUpdatetime" in line:
                swp_file.writelines("** @LastUpdatetime %s \n" % time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
                continue
            if "** new added **" in line or "** end new added **" in line:
                continue        
            if "/** translate content start **/" in line:
                is_trans_area = True
                swp_file.writelines(line)
                continue
            if "/** translate content end **/" in line:
                is_trans_area = False
                swp_file.writelines("\t\t/** new added **/\n")
                for l in langs:
                    if l not in writed:
                        swp_file.writelines("\t\t\"%s\":\"\",\n" % l)
                swp_file.writelines("\t\t/** end new added **/\n")
                swp_file.writelines(line)
                continue

            if is_trans_area:
                text = line.strip("\t").split("\":\"")[0].strip("\"")
                if text in langs:
                    swp_file.writelines(line)
                    writed.append(text)
            else:
                swp_file.writelines(line)
        swp_file.flush()
        swp_file.close()
        # copy swp file to override source file
        shutil.copy2(swp_file_full_path,export_full_path)
        os.remove(swp_file_full_path)

    def load(self,langs=[]):
        """装载词组
        Args:
        langs:词汇数组，格式如["投币","出票"]
        Returns:
        返回装载了词组的Generator实例
        """
        self.langs = langs
        return self

    def flush(self):
        """保存缓冲区的内容到实例指定的路径
        """
        if self.mode == "a":
            self.__create__()
            return
        
        if self.mode == "u":
            self.__update__()
            return
        
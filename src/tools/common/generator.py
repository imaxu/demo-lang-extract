# -*- coding:utf-8 -*-

class Generator(object):
    """多语言词典脚本生成器

    提供对已提取词组生成language.js文件。
    """
    def __init__(self,path,mode,lang="zh-cn"):
        """
        Args:
            path:生成文件的保存路径。
            mode:指定生成器模式，A = Create 创建模式  U = Update 更新模式。
        Returns:
            Raises:
                AttributeError:缺少参数或者参数超出范围
        """
        if not path or len(path) == 0:
            raise AttributeError("invalid path") 
        self.path = path

        if not mode or str.lower(mode) not in ["a","u"]:
            raise AttributeError("invalid mode with %s" % mode) 
        self.mode = str.lower(mode)
        if not lang:
            raise AttributeError("invalid lang") 
        self.lang = str.lower(lang)

        self.__header_str__ = "@Auth -- generated by lang_extract.py"
        self.__start_str__ = "// auto content start"
        self.__end_str__ = "// auto content end"
        self.__added_start__ = "// Added"
        self.__added_end__ ="// end Added"
        self.__custom_start__ = "// custom content start"
        self.__custom_end__ = "// end custom content"

    def __create__(self):
        import os,time
        full_path = self.path
        file_path,file_name = os.path.split(full_path)

        if os.access(full_path, os.F_OK):
            os.remove(full_path)
        if not os.path.exists(file_path):
            os.makedirs(file_path)

        file = open(full_path,"a+",encoding="UTF-8")
        file.writelines("/**\t%s \n" % self.__header_str__)
        file.writelines("**\t@Desc 注意！！！在\"auto content\"区域内的内容将会被工具复写，不要在其中自定义内容！！！\n")
        file.writelines("**\t可在\"custom content\"区域内编写自定义内容。 \n")
        file.writelines("**\t@LastUpdatetime %s \n" % time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
        file.writelines("**/\n")
        file.writelines("var _dict = (function(){\n")
        file.writelines("\treturn {\n")
        file.writelines("\t\t\"lang_name\":\"%s\",\n" % self.lang)

        file.writelines("\t\t%s\n\n" % self.__custom_start__)
        file.writelines("\t\t//本块内容不会被自动化工具编辑，可在本块内编辑自定义内容，也可以放开下面注释测试。\n")
        file.writelines("\t\t//\"自定义内容\":\"custom content\",\n\n\n")
        file.writelines("\t\t%s\n\n\n" % self.__custom_end__)

        file.writelines("\t\t%s\n\n" % self.__start_str__)
        # generate translate contents.
        for l in self.langs: 
            for k,v in l.items(): 
                file.writelines("\t\t\"%s\":\"%s\",\n\n" %(k,v))
        # / generate translate contents.
        file.writelines("\t\t%s\n\n\n" % self.__end_str__)

        file.writelines("\t};\n")
        file.writelines("})();\n")
        file.flush()
        file.close()
    
    def __update__(self):
        import shutil,os,time
        export_full_path = self.path

        if not os.path.exists(export_full_path):
            raise RuntimeError("file is not exists,we can not update data.path:%s" % export_full_path)

        langs = self.langs
        swp_file_full_path = "%s.swp" % export_full_path
        bak_file_full_path = "%s.bak" % export_full_path

        shutil.copy2(export_full_path,swp_file_full_path)
        shutil.copy2(export_full_path,bak_file_full_path)

        swp_file = open(swp_file_full_path,"w+",encoding="UTF-8")
        source_file = open(export_full_path,"r",encoding="UTF-8")

        is_trans_area = False
        writed = []
        all_keys = []
        for l in langs:
            for k,v in l.items():
                all_keys.append(k)

        for index,line in enumerate(source_file):
            if "@LastUpdatetime" in line:
                swp_file.writelines("** @LastUpdatetime %s \n" % time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))
                continue
            if self.__added_start__ in line or self.__added_end__ in line:
                continue        
            if self.__start_str__ in line:
                is_trans_area = True
                swp_file.writelines(line)
                continue
            if line.startswith("//"):
                swp_file.writelines(line)
                continue
            if self.__end_str__ in line:
                is_trans_area = False
                swp_file.writelines("\t\t%s\n\n" % self.__added_start__)
                for l in langs:
                    for k,v in l.items():         
                        if k not in writed:
                            swp_file.writelines("\t\t\"%s\":\"%s\",\n\n" % (k,v))
                swp_file.writelines("\t\t%s\n\n\n" % self.__added_end__)
                swp_file.writelines(line)
                continue

            if is_trans_area:
                text = line.strip("\t").split("\":\"")[0].strip("\"")
                if text in all_keys:
                    swp_file.writelines("%s\n" % line)
                    writed.append(text)
            else:
                swp_file.writelines(line)
        swp_file.flush()
        swp_file.close()
        # copy swp file to override source file
        shutil.copy2(swp_file_full_path,export_full_path)
        os.remove(swp_file_full_path)

    def load(self,langs=[]):
        """装载词组
        Args:
        langs:词汇数组，格式如["投币","出票"]
        Returns:
        返回装载了词组的Generator实例
        """
        self.langs = langs
        return self

    def flush(self):
        """保存缓冲区的内容到实例指定的路径
        """
        if self.mode == "a":
            self.__create__()
            return
        
        if self.mode == "u":
            self.__update__()
            return
        